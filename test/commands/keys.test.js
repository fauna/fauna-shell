const { expect, test } = require('@oclif/test')
const { query: q, values } = require('faunadb')
const { withOpts, getEndpoint, matchFqlReq } = require('../helpers/utils.js')

const currentKeys = {
  name: '[current]',
  keys: { data: [{ id: 1, role: 'admin' }] },
}
const childrenKeys = {
  name: 'nested',
  keys: { data: [{ id: 2, role: 'server' }] },
}

const keyname = '296492256109527557'
const dbname = 'test'

describe('keys test', () => {
  test
    .nock(getEndpoint(), { allowUnmocked: true }, (api) =>
      api
        .persist()
        .post('/', matchFqlReq(q.Paginate(q.Keys(), { size: 100 })))
        .reply(200, { resource: currentKeys })
        .post('/', matchFqlReq(q.Paginate(q.Databases(), { size: 100 })))
        .reply(200, { resource: { data: [childrenKeys] } })
    )
    .stdout()
    .command(withOpts(['list-keys']))
    .add('output_keys', (ctx) => {
      var lines = ctx.stdout.split('\n')
      lines.splice(0, 1)
      return lines.map((l) => l.replace(/ /g, ''))
    })
    .it('runs list-keys', (ctx) => {
      expect(ctx.output_keys).to.include.members([
        ...currentKeys.keys.data.map(
          ({ id, role }) => `${id}${currentKeys.name}${role}`
        ),
        ...childrenKeys.keys.data.map(
          ({ id, role }) => `${id}${childrenKeys.name}${role}`
        ),
      ])
    })

  test
    .nock(getEndpoint(), { allowUnmocked: true }, (api) =>
      api
        .persist()
        .post('/', matchFqlReq(q.Exists(q.Database(dbname))))
        .reply(200, { resource: false })
    )
    .command(withOpts(['create-key', dbname]))
    .catch((err) => {
      expect(err.message).to.contain(`Database '${dbname}' doesn't exist`)
      expect(err.oclif.exit).to.equal(1)
    })
    .it('runs create-key for non exists db')

  test
    .nock(getEndpoint(), { allowUnmocked: true }, (api) =>
      mockCreateKey(api, { role: 'admin' })
    )
    .stdout()
    .command(withOpts(['create-key', dbname]))
    .it('runs create-key testdb', (ctx) => {
      expect(ctx.stdout).to.contain(
        `created key for database '${dbname}' with role 'admin'.`
      )
    })

  test
    .nock(getEndpoint(), { allowUnmocked: true }, (api) =>
      mockCreateKey(api, { role: 'server' })
    )
    .stdout()
    .command(withOpts(['create-key', dbname, 'server']))
    .it('runs create-key testdb with a different role', (ctx) => {
      expect(ctx.stdout).to.contain(
        `created key for database '${dbname}' with role 'server'.`
      )
    })

  test
    .stdout()
    .command(withOpts(['create-key', dbname, 'other']))
    .catch((err) => {
      expect(err.message).to.contain('Expected other to be one of')
      //the actual error code is 2, but this is generated by oclif, so we don't want to be coupled to it.
      expect(err.oclif.exit).to.not.equal(0)
    })
    .it('runs create-key testdb with a wrong role')

  test
    .nock(getEndpoint(), { allowUnmocked: true }, (api) =>
      api
        .persist()
        .post('/', matchFqlReq(q.Delete(q.Ref(q.Keys(null), keyname))))
        .reply(200, { resource: { ref: new values.Ref(keyname) } })
    )
    .stdout()
    .command(withOpts(['delete-key', keyname]))
    .it('runs delete-key', (ctx) => {
      expect(ctx.stdout).to.contain(`key ${keyname} deleted`)
    })

  test
    .nock(getEndpoint(), { allowUnmocked: true }, (api) =>
      api
        .persist()
        .post('/', matchFqlReq(q.Delete(q.Ref(q.Keys(null), keyname))))
        .reply(400, {
          errors: [
            {
              position: [],
              code: 'instance not found',
              description: 'Key not found.',
            },
          ],
        })
    )
    .stdout()
    .command(withOpts(['delete-key', keyname]))
    .catch((err) => {
      expect(err.message).to.contain(`Key ${keyname} not found`)
    })
    .it('runs delete-key for not exist key')
})

function mockCreateKey(api, { role }) {
  api
    .persist()
    .post('/', matchFqlReq(q.Exists(q.Database(dbname))))
    .reply(200, { resource: true })
    .post('/', matchFqlReq(q.Now()))
    .reply(200, new Date())
    .post('/', matchFqlReq(q.CreateKey({ role })))
    .reply(function (_, reqBody) {
      const { role } = JSON.parse(reqBody).create_key.object
      const authParsed = this.req.headers.authorization[0].split(':')
      const allowedRoles = ['admin', 'server', 'server-readonly', 'client']
      if (allowedRoles.includes(role)) {
        return [
          200,
          {
            resource: {
              role,
              database: new values.Ref(authParsed[1]),
            },
          },
        ]
      }

      return [400, {}]
    })
}
